# E. Межвременная дефрагментация (60 баллов)

Сотрудники отдела Темпоральной Обработки Информации нашли новый способ почти бесконечно увеличивать объём физических носителей данных. Оказывается, если выстроить непрерывный кварковый блок данных между антикварковым покрытием стенок носителя, то аннигилированные частицы одного типа попадают в межвременное пространство, к которому всё ещё можно получить доступ по флуктуациям в пространстве-времени от высвобождения фотонов. Для тестирования способа учёные придумали устройство, которое позволяет вручную дефрагментировать данные. Вам нужно создать визуальный интерфейс для этого устройства.

## Правила игры простые: 
- карта носителя данных может состоять из стенок, пустых полей, подвижного блока и зафиксированных блоков;
подвижный блок может перемещаться на одно поле влево, вправо и вниз с помощью кнопок управления: arrow-left arrow-down arrow-right;
- подвижный блок может поворачиваться на 90 градусов (относительно центральной клетки) и менять цвет (тип кварка) между двумя возможными с помощью кнопок управления: arrow-up close;
полный список возможных подвижных блоков (с учётом порядка при изменении):
```
[  
    `
    o  
    o  
    o  
    `,  
    `  
    q  
    q  
    q  
    `,  
    `  
    ooo  
    `,  
    `  
    qqq  
    `  
]  
`;
```
- после движения вправо-влево и после замены подвижный блок дополнительно двигается вниз на одно поле;
если движение вправо-влево или замена невозможны из-за близости стенок или зафиксированных блоков, то действие игнорируется (при этом дополнительное движение вниз всё равно происходит);
- когда подвижный блок при движении вниз упирается в стенку или зафиксированный блок, он фиксируется;
- после фиксации подвижного блока все полные горизонтальные линии зафиксированных блоков одного цвета исчезают;
- после фиксации подвижного блока (и исчезновения полных горизонтальных линий одного цвета, если таковые были) следующий блок появляется вверху карты и посредине по горизонтали (все карты и блоки нечётной ширины);
- если новому блоку негде появиться (из-за накопившихся зафиксированных блоков), то дефрагментация заканчивается — все зафиксированные блоки превращаются в стенки.

## Формат ввода

Карта носителя доступна в поле window.map типа String.

## Специальные символы:

- \# — стенка;
- . — пустое место;
- o, q — часть подвижного блока (два разных цвета);
- O, Q — зафиксированная часть блока (два разных цвета).

Каждая строка, содержащая хотя бы один специальный символ, является линией карты, каждый символ является полем карты. Любые другие символы не имеют значения и должны быть проигнорированы при построении карты.
Например, 

```
window.map = `
    #..o..#  
    #..o..#  
    #..o..#  
    #.....#  
    #..OQ.#  
    #######  
`;
```
должно дать такой результат: 

PIC(example.png)

## Примечания

Все карты в наших тестах имеют прямоугольную форму (нечётной ширины) и ограничены стенками по бокам и снизу.
Решение должно представлять из себя один HTML-файл, содержащий все нужные скрипты и стили.

После того, как интерфейс будет проинциализирован, надо вызвать глобальную функцию window.onGameReady(). Только после этого будет запущено автоматическое тестирование вашего решения. Если вызов функции не произойдёт в течение 2 минут, то задание считается невыполненным. 

Контейнер с картой должен иметь CSS-класс map.

Кнопки управления должны реагировать на событие click и иметь следующие CSS-классы:
- влево — control_action_left;
- вниз — control_action_down;
- вправо — control_action_right;
- повернуть блок — control_action_switch-figure;
- поменять цвет блока — control_action_switch-color.

Значения цвета для разных элементов карты:
- задний фон: 35004d;
- декоративная сетка: 6c4080;
- стенка: ffb971, ff7a00, ffa03f;
- фигура первого цвета: c100ff, dd71ff;
- фигура второго цвета: 00ff73, 71ffc9.

Обратите внимание, ваше решение будет тестироваться в браузере Google Chrome 69.